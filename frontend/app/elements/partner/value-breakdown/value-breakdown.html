
<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-fab/paper-fab.html">
<link rel="import" href="../input-recursive/input-recursive.html">

  


<dom-module id="value-breakdown">
  <style>

  
  </style>
  <template>

    <paper-input type="number" label="Total"></paper-input>
      <template is="dom-if" if="{{breakdowns.breakdown}}">
        <p>
          <template is="dom-repeat" items="{{disaggregation.order}}">
            <span on-tap="_selectLevel" data-lvl="{{index}}">{{_computeItem(index)}}</span> |
          </template>
        </p>
      <p> selected: {{disLevel}} </p>

      <input-recursive hidden$="{{!disLevel}}" level="{{disLevel}}" breakdown="{{breakdowns.breakdown}}"></input-recursive>
    </template>

   
    <!-- <template is="dom-repeat" items="">
    
    </template> -->
  
  </template>
</dom-module>


<script>
(function() {
    // jscs:disable
  'use strict';
  Polymer({
    is: 'value-breakdown',
    behaviors: [],
    properties: {
      disaggregation: {
        type: Object
      },
      breakdowns: {
        type: Object
      },
      disLevel: {
        type: Number,
        value: 0
      }
           
      
    },
    ready: function() {
      this.recursiveMap(this.disaggregation);
    },
    
    recursiveMap: function(d){
      if (!d) { return; }
      var order = d.order;
      var tempLol = [];
      order.forEach(function (e){
        tempLol.push(d[e]);
      });

      var mr = function(cln, lol) {
        var myL = [];
        if (lol.length === 1) {
          
          for (var k in lol[0]){
            myL.push(
              {
                name: lol[0][k],
                total: null,
                breakdown: null
              }
            );
          }
          return myL;
        } else {
          for (var l in lol[0]){
            myL.push(
              {
                name: lol[0][l],
                total: null,
                breakdown: {
                  breakdownName: order[cln],
                  children: mr(cln+1, lol.slice(1))
                }
              }
            );
          }
          return myL;
        }
      };

    var result = { 
      name: 'total',
      total: null,
      breakdown: {
        breakdownName: order[0],
        children: mr(1, tempLol)
      }
    };
    //result.breakdown.children = mr(1, tempLol);
    //console.log(result);
    this.breakdowns = result;
    },
    _selectLevel: function(ev) {
      this.disLevel = 1 + ev.model.index;
    },
    _hidenBreakdowns: function(e) {
      return e ? false : true;
    },
    _computeItem: function(index) {
      var myDis = [];
      for (var i=0; i<=index; i++){
        myDis.push(this.disaggregation.order[i]);
      }
      return myDis.join(' + ');
    }
    
  });
})();

</script>